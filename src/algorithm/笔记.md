#### 1.时间与空间复杂度
时间复杂度：评价算法性能之一。
公式表示：不要低阶项、去掉最高阶系数，O(n^2)表示时间复杂度收敛于n^2。
- 常数操作：花费时间与数据量无关O(1)，一般常数时间用C表示。
- 二分算法时间复杂度：O(log2N) ==> O(logN)
- 其他形式：O(N*M)、O(N*logM)、O(N+M)

空间复杂度：指额外空间复杂度。程序要求输入输出所占的空间不算，而是在实现过程中所使用的辅助空间。
- 常数空间O(1)，即所需辅助空间与要处理的数据量无关

最优解：先满足时间复杂度最优下空间复杂度尽量小（除非特殊声明）。

#### 2.排序算法
排序算法的稳定性：在无序序列中，值相同的元素其相对位置，在排序后保持一致！<br/>
- 稳定排序：冒泡、插入、归并
- 不稳定：选择(因为选择的最小值要和前面的元素交换，可能打乱相同值的次序)、快排(因为划分过程是不稳定的，遇到遇到大值时需要与大于区前的元素交换位置，这就可能扰乱相同元素相对位置)、堆排序

1. 冒泡排序
    - 对数器生成随机字符串：使用字符数组，随机取字符存到字符数组，再转换成字符串。
2. 选择排序
3. 插入排序
4. 归并排序
    - 求小和问题
    - 求逆序对问题
5. 快速排序
<br/>经典快排始终拿最后一个元素作为划分元素，会有最好O(NlogN)最差O(N^2)情况。而随机快排每次随机地选择一个元素作为划分元素与最后一个元素交换后再进行经典快排，因为是概率问题，所以期望时间复杂度为O(NlogN)且常数项比较小。
    - 荷兰国旗问题
    - 数组只有：0,1,2。要求对数组排序：左边全0，中间全1，右边全2。
    - 恶心问题：数组有奇偶数，在空间复杂度为O(1)下，让数组左边奇数、右边偶数且奇偶数各自的顺序保持不变。这个问题需要用`stable sort`稳定快排来实现。

6. 堆排序
<br/>堆结构：概念上是完全二叉树，一定是从上往下从左往右依次添加节点。而**实现堆的真实结构是数组**。
<br/>时间复杂度由2部分组成：(1)建堆：`log1+log2+...+log(N-1)`等价于`O(N)` (2)调整堆：因为最后一层节点调整最坏情况都需要`O(logN)`，故整个过程`O(NlogN)`且常数项比较大，故不常用堆排序。但堆结构使用非常多。
    - 已知父节点索引i，子节点索引：左2*i+1、右2*i+2
    - 已知子节点索引i，其父节点索引：(i-1)/2
    - 大顶堆：每棵树的最大值位于根结点，子节点一定小于等于父节点，每棵子树也是，而兄弟节点大小关系不定。小顶堆：类似的堆顶为最小值。

    建立大顶堆：从首元素开始将数组元素依次插入到堆的末尾，然后从下往上调整堆，将新加节点不断与父节点比较，直到没有节点交换值(即符合大顶堆结构)或到堆顶停止。<font color=red>大顶堆可能是无序的</font>。<br/>
    **构建大顶堆后再需要再调整**：将堆顶元素与堆最后一个交换后，堆大小减一，相当于排除顶堆元素(实质就将最大元素放到数组末尾了)。然后再从堆顶开始从上往下调整堆，若子节点比父节点大就交换，直到堆底或没有节点交换值。当堆大小减为0时，数组就是有序的了。

    堆排序过程：
    1. 将传入数组建立大顶堆
    2. 通过不断去掉堆顶元素来排序，直到堆大小减为0，此时数组有序

    注：堆大小与底层数组长度不一定一致！数组只是存放堆元素的容器。




贪心算法：提出一种策略，按照这种策略去寻找答案。策略有很多种，各个策略下得到的答案不一定就是正确答案！
为什么某些贪心策略就是能得到正确答案呢？需要证明，现阶段无需去证明，很难！
可以使用对数器来验证你的某个猜想策略的正确性，使用暴力求解得到的正确解与某个贪心策略结果比对，若多样本下全对，那么基本可确定该策略的正确性！



