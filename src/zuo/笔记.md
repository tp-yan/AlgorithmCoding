#### 1.时间与空间复杂度
时间复杂度：评价算法性能之一。
公式表示：不要低阶项、去掉最高阶系数，O(n^2)表示时间复杂度收敛于n^2。
- 常数操作：花费时间与数据量无关O(1)，一般常数时间用C表示。
- 二分算法时间复杂度：O(log2N) ==> O(logN)
- 其他形式：O(N*M)、O(N*logM)、O(N+M)

空间复杂度：指额外空间复杂度。程序要求输入输出所占的空间不算，而是在实现过程中所使用的辅助空间。
- 常数空间O(1)，即所需辅助空间与要处理的数据量无关

最优解：先满足时间复杂度最优下空间复杂度尽量小（除非特殊声明）。

#### 2.排序算法
排序算法的稳定性：在无序序列中，值相同的元素其相对位置，在排序后保持一致！<br/>
- 稳定排序：冒泡、插入、归并！
- 不稳定：选择(因为选择的最小值要和前面的元素交换，可能打乱相同值的次序)、快排(因为划分过程是不稳定的，遇到遇到大值时需要与大于区前的元素交换位置，这就可能扰乱相同元素相对位置)、堆排序！

1. 冒泡排序
    - 对数器生成随机字符串：使用字符数组，随机取字符存到字符数组，再转换成字符串。
2. 选择排序
3. 插入排序
4. 归并排序
    - 求小和问题
    - 求逆序对问题
5. 快速排序
<br/>经典快排始终拿最后一个元素作为划分元素，会有最好O(NlogN)最差O(N^2)情况。而随机快排每次随机地选择一个元素作为划分元素与最后一个元素交换后再进行经典快排，因为是概率问题，所以期望时间复杂度为O(NlogN)且常数项比较小。
    - 荷兰国旗问题
    - 数组只有：0,1,2。要求对数组排序：左边全0，中间全1，右边全2。
    - 恶心问题：数组有奇偶数，在空间复杂度为O(1)下，让数组左边奇数、右边偶数且奇偶数各自的顺序保持不变。这个问题需要用`stable sort`稳定快排来实现。

6. 堆排序
<br/>堆结构：概念上是完全二叉树，一定是从上往下从左往右依次添加节点。而**实现堆的真实结构是数组**。
<br/>时间复杂度由2部分组成：(1)建堆：`log1+log2+...+log(N-1)`等价于`O(N)` (2)调整堆：因为最后一层节点调整最坏情况都需要`O(logN)`，故整个过程`O(NlogN)`且常数项比较大，故不常用堆排序。但堆结构使用非常多。
    - 已知父节点索引i，子节点索引：左2*i+1、右2*i+2
    - 已知子节点索引i，其父节点索引：(i-1)/2
    - 大顶堆：每棵树的最大值位于根结点，子节点一定小于等于父节点，每棵子树也是，而兄弟节点大小关系不定。小顶堆：类似的堆顶为最小值。

    建立大顶堆：从首元素开始将数组元素依次插入到堆的末尾，然后从下往上调整堆，将新加节点不断与父节点比较，直到没有节点交换值(即符合大顶堆结构)或到堆顶停止。<font color=red>大顶堆可能是无序的</font>。<br/>
    **构建大顶堆后再需要再调整**：将堆顶元素与堆最后一个交换后，堆大小减一，相当于排除顶堆元素(实质就将最大元素放到数组末尾了)。然后再从堆顶开始从上往下调整堆，若子节点比父节点大就交换，直到堆底或没有节点交换值。当堆大小减为0时，数组就是有序的了。

    堆排序过程：
    1. 将传入数组建立大顶堆
    2. 通过不断去掉堆顶元素来排序，直到堆大小减为0，此时数组有序

    注：堆大小与底层数组长度不一定一致！数组只是存放堆元素的容器。

7. 桶排序
桶就是一个容器，底层数据结构可以是栈、队列、列表、链表都行。使用桶排序需要基于数据状况。
- 桶排序的稳定性取决于底层容器，比如容器是队列则是稳定的，若是栈就不是稳定的。
- 时间复杂度O(n)：只需要遍历数组然后入桶出桶即可;空间复杂度O(n)：所有桶的大小就是数组个数n
- 2种桶排序实现：(1)计数排序：统计每个桶出现的频率。(2)基数排序。

补充：`Arrays.sort()`：采用的综合排序，若 `size < 60`则采用插入排序，否则采用归并或快排。在归并和快排的分支过程中，若子段`size < 60`时，也采用插入排序。因为插入排序的常数项小，当数据量小时效率高。<font color=red>当排序内容是基本数据类型时采用快排，否则采用归并。这是因为归并是稳定了，而快排是不稳定的！基础类型不关心相对次序。</font>

#### 3.数据结构
##### 1.数组实现栈和队列
- 数组实现栈只需一个变量`size`即可，`size`指示栈大小同时也指向了栈顶位置。
- 数组实现队列时，复用了数组。需要使用`size`变量指示队列大小，同时将 start和end指针解耦合，使指针之间毫无联系，指针操作只需size即可。
##### 2.特殊栈：在O(1)时间内返回栈内最小值
- 实现1：使用2个栈：一个存数据(数据栈)，另一个存当前栈内最小值(min栈)。这2个栈同步压栈、出栈。当数据栈压入新值时，若比min栈栈顶元素小，则同时压入min栈，否则将min栈顶元素再次压入min栈。
- 实现2(判断比实现1复杂，但节约点空间)：使用2个栈：一个存数据，另一个同步存当前栈内最小值。只有当数据栈中压入 <= min栈顶元素时才将其压入min栈，否则min栈不压入。
##### 3.队列和栈相互实现
- 使用队列实现栈：使用2个队列，将有元素的队列前n-1的元素，出队放到无元素的队列中，剩下的第n个元素则是栈顶元素弹出。现在之前有元素的队列变成空，空队列有元素。现在操作时就这样在2个队列间来回导元素。
- 使用栈实现队列：使用2个栈：poll栈和push栈。元素只能从poll栈弹出、压入push栈。同时必须遵守2条原则：
    1. 当poll栈还有元素时不能从push导入元素
    2. push栈导出元素时，必须一次性全部导完

<font color=red>扩展面试题目</font>：**使用队列实现图的深度优先遍历。经典解法使用栈结构，现在可以使用队列实现的栈来完成深度优先遍历。**

##### 4.猫狗队列
准备猫队列(只放猫)和狗队列(只放猫)，对如队列的猫狗类封装一个统一的指示它们入队列的先后顺序的量。相当于给它们打上了一个时间戳。使得它们在各自的队列可以比较先后顺序，同时猫和狗的任何入队的实例也可以比较先后顺序。

注：不能修改题目给出的源代码，因为在工程上，是无法修改源码的jar包的。

##### 5.哈希函数和哈希表
哈希函数有：md5(2^64)、sha1(2^128)数百种实现。哈希函数有如下4点性质：
- 输入域(字符串)无限、输出域(数值)有限。
- 不是随机函数，同一个输入，输出一定相同。
- 不同输入也有可能会有相同输出。因为 输入域 >> 输出域 范围。(哈希碰撞、冲突)
- <font color=red>离散性(均匀分布性)</font>：假设输入域为`0~99`，而输出域为`0,1,2`。若将输入域`0~99`全输入哈希函数，则得到的输出域`0,1,2`的个数差不多相同(即都33个左右)。离散性越好，哈希函数越好！

延伸：哈希值 % m 结果还是均匀的，前提是m是素数，若不是不能保证均匀分布。HashTable默认的初始长度为11。

哈希表(散列表)
- 经典实现：将插入元素值作为key计算哈希值。然后哈希值%表的长度，即为元素在哈希表上的存放位置。当表长度有限时，每个元素上链表的长度也差不多(离散性)。
- 扩容：设置链表长度阈值，只要有一个链表超过这个长度，就扩展哈希表长度为2倍，所有的元素重新计算哈希值和位置，重新存放，时间复杂度O(n)。
- 现在Java在哈希表后面连接的是**红黑树**而不是链表。更高效。
- `HashSet`和`HashMap`结构相同，都是基于哈希表。
- 哈希函数增删改查操作都认为是O(1)，但常数项比较大，哈希函数计算代价比较高。

题目：设计RandomPool结构。












#### 其他补充
贪心算法：提出一种策略，按照这种策略去寻找答案。策略有很多种，各个策略下得到的答案不一定就是正确答案！
为什么某些贪心策略就是能得到正确答案呢？需要证明，现阶段无需去证明，很难！
可以使用对数器来验证你的某个猜想策略的正确性，使用暴力求解得到的正确解与某个贪心策略结果比对，若多样本下全对，那么基本可确定该策略的正确性！



