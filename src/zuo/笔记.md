#### 1.时间与空间复杂度
时间复杂度：评价算法性能之一。
公式表示：不要低阶项、去掉最高阶系数，O(n^2)表示时间复杂度收敛于n^2。
- 常数操作：花费时间与数据量无关O(1)，一般常数时间用C表示。
- 二分算法时间复杂度：O(log2N) ==> O(logN)
- 其他形式：O(N*M)、O(N*logM)、O(N+M)

空间复杂度：指额外空间复杂度。程序要求输入输出所占的空间不算，而是在实现过程中所使用的辅助空间。
- 常数空间O(1)，即所需辅助空间与要处理的数据量无关

最优解：先满足时间复杂度最优下空间复杂度尽量小（除非特殊声明）。

#### 2.排序算法
排序算法的稳定性：在无序序列中，值相同的元素其相对位置，在排序后保持一致！<br/>
- 稳定排序：冒泡、插入、归并！
- 不稳定：选择(因为选择的最小值要和前面的元素交换，可能打乱相同值的次序)、快排(因为划分过程是不稳定的，遇到遇到大值时需要与大于区前的元素交换位置，这就可能扰乱相同元素相对位置)、堆排序！

1. 冒泡排序
    - 对数器生成随机字符串：使用字符数组，随机取字符存到字符数组，再转换成字符串。
2. 选择排序
3. 插入排序
4. 归并排序
    - 求小和问题
    - 求逆序对问题
5. 快速排序
<br/>经典快排始终拿最后一个元素作为划分元素，会有最好O(NlogN)最差O(N^2)情况。而随机快排每次随机地选择一个元素作为划分元素与最后一个元素交换后再进行经典快排，因为是概率问题，所以期望时间复杂度为O(NlogN)且常数项比较小。
    - 荷兰国旗问题
    - 数组只有：0,1,2。要求对数组排序：左边全0，中间全1，右边全2。
    - 恶心问题：数组有奇偶数，在空间复杂度为O(1)下，让数组左边奇数、右边偶数且奇偶数各自的顺序保持不变。这个问题需要用`stable sort`稳定快排来实现。

6. 堆排序
<br/>堆结构：概念上是完全二叉树，一定是从上往下从左往右依次添加节点。而**实现堆的真实结构是数组**。
<br/>时间复杂度由2部分组成：(1)建堆：`log1+log2+...+log(N-1)`等价于`O(N)` (2)调整堆：因为最后一层节点调整最坏情况都需要`O(logN)`，故整个过程`O(NlogN)`且常数项比较大，故不常用堆排序。但堆结构使用非常多。
    - 已知父节点索引i，子节点索引：左2*i+1、右2*i+2
    - 已知子节点索引i，其父节点索引：(i-1)/2
    - 大顶堆：每棵树的最大值位于根结点，子节点一定小于等于父节点，每棵子树也是，而兄弟节点大小关系不定。小顶堆：类似的堆顶为最小值。

    建立大顶堆：从首元素开始将数组元素依次插入到堆的末尾，然后从下往上调整堆，将新加节点不断与父节点比较，直到没有节点交换值(即符合大顶堆结构)或到堆顶停止。<font color=red>大顶堆可能是无序的</font>。<br/>
    **构建大顶堆后再需要再调整**：将堆顶元素与堆最后一个交换后，堆大小减一，相当于排除顶堆元素(实质就将最大元素放到数组末尾了)。然后再从堆顶开始从上往下调整堆，若子节点比父节点大就交换，直到堆底或没有节点交换值。当堆大小减为0时，数组就是有序的了。

    堆排序过程：
    1. 将传入数组建立大顶堆
    2. 通过不断去掉堆顶元素来排序，直到堆大小减为0，此时数组有序

    注：堆大小与底层数组长度不一定一致！数组只是存放堆元素的容器。

7. 桶排序
桶就是一个容器，底层数据结构可以是栈、队列、列表、链表都行。使用桶排序需要基于数据状况。
- 桶排序的稳定性取决于底层容器，比如容器是队列则是稳定的，若是栈就不是稳定的。
- 时间复杂度O(n)：只需要遍历数组然后入桶出桶即可;空间复杂度O(n)：所有桶的大小就是数组个数n
- 2种桶排序实现：(1)计数排序：统计每个桶出现的频率。(2)基数排序。

补充：`Arrays.sort()`：采用的综合排序，若 `size < 60`则采用插入排序，否则采用归并或快排。在归并和快排的分支过程中，若子段`size < 60`时，也采用插入排序。因为插入排序的常数项小，当数据量小时效率高。<font color=red>当排序内容是基本数据类型时采用快排，否则采用归并。这是因为归并是稳定了，而快排是不稳定的！基础类型不关心相对次序。</font>

#### 3.数据结构
##### 1.数组实现栈和队列
- 数组实现栈只需一个变量`size`即可，`size`指示栈大小同时也指向了栈顶位置。
- 数组实现队列时，复用了数组。需要使用`size`变量指示队列大小，同时将 start和end指针解耦合，使指针之间毫无联系，指针操作只需size即可。
##### 2.特殊栈：在O(1)时间内返回栈内最小值
- 实现1：使用2个栈：一个存数据(数据栈)，另一个存当前栈内最小值(min栈)。这2个栈同步压栈、出栈。当数据栈压入新值时，若比min栈栈顶元素小，则同时压入min栈，否则将min栈顶元素再次压入min栈。
- 实现2(判断比实现1复杂，但节约点空间)：使用2个栈：一个存数据，另一个同步存当前栈内最小值。只有当数据栈中压入 <= min栈顶元素时才将其压入min栈，否则min栈不压入。
##### 3.队列和栈相互实现
- 使用队列实现栈：使用2个队列，将有元素的队列前n-1的元素，出队放到无元素的队列中，剩下的第n个元素则是栈顶元素弹出。现在之前有元素的队列变成空，空队列有元素。现在操作时就这样在2个队列间来回导元素。
- 使用栈实现队列：使用2个栈：poll栈和push栈。元素只能从poll栈弹出、压入push栈。同时必须遵守2条原则：
    1. 当poll栈还有元素时不能从push导入元素
    2. push栈导出元素时，必须一次性全部导完

<font color=red>扩展面试题目</font>：**使用队列实现图的深度优先遍历。经典解法使用栈结构，现在可以使用队列实现的栈来完成深度优先遍历。**

##### 4.猫狗队列
准备猫队列(只放猫)和狗队列(只放猫)，对如队列的猫狗类封装一个统一的指示它们入队列的先后顺序的量。相当于给它们打上了一个时间戳。使得它们在各自的队列可以比较先后顺序，同时猫和狗的任何入队的实例也可以比较先后顺序。

注：不能修改题目给出的源代码，因为在工程上，是无法修改源码的jar包的。

##### 5.哈希函数和哈希表
哈希函数有：md5(2^64)、sha1(2^128)数百种实现。哈希函数有如下4点性质：
- 输入域(字符串)无限、输出域(数值)有限。
- 不是随机函数，同一个输入，输出一定相同。
- 不同输入也有可能会有相同输出。因为 输入域 >> 输出域 范围。(哈希碰撞、冲突)
- <font color=red>离散性(均匀分布性)</font>：假设输入域为`0~99`，而输出域为`0,1,2`。若将输入域`0~99`全输入哈希函数，则得到的输出域`0,1,2`的个数差不多相同(即都33个左右)。离散性越好，哈希函数越好！

延伸：哈希值 % m 结果还是均匀的，前提是m是素数，若不是不能保证均匀分布。HashTable默认的初始长度为11。

哈希表(散列表)
- 经典实现：将插入元素值作为key计算哈希值。然后哈希值%表的长度，即为元素在哈希表上的存放位置。当表长度有限时，每个元素上链表的长度也差不多(离散性)。
- 扩容：设置链表长度阈值，只要有一个链表超过这个长度，就扩展哈希表长度为2倍，所有的元素重新计算哈希值和位置，重新存放，时间复杂度O(n)。
- 现在Java在哈希表后面连接的是**红黑树**而不是链表。更高效。
- `HashSet`和`HashMap`结构相同，都是基于哈希表。
- 哈希函数增删改查操作都认为是O(1)，但常数项比较大，哈希函数计算代价比较高。

题目：设计RandomPool结构。

##### 6.转圈打印矩阵
关键：用2个点代表当前打印矩阵边的左上角和右下角，然后以这2个点作为限制边界，打印矩阵外围。下一步将左上角点往右下移，右下角点往左上角移，现在这2个点就指示了下一个要打印矩阵的边界。当左上角点越过右下角点时停止。

**注：考虑只有一行或一列的特殊矩阵！**
##### 7.“之”字型打印矩阵
关键：用2个点指示当前要打印的矩阵某一个对角线上元素范围。每次同时移动2个点，一次打印一个矩阵的对角线元素。同时需要一个变量指示是按斜上还是斜下方向打印元素。<br/>
<font color=red>警告：千万不要去想局部位置变换下标如何变换来满足运动轨迹(太多限制)，而是设计**宏观调度策略**。</font>

##### 8.在行列都排好序的矩阵中找数
从右上角元素开始依次与K比较，若K小于该元素，那么该列元素都大于K，则向左移动比较该元素的左边元素，若K大于该元素，该元素左边的元素都比K小，则比较该元素的下一个元素。只能向左或向下移动，若越界则表示没找到。
##### 9.打印2个有序链表的公共部分
和归并排序的合并过程类似，谁小移谁。
##### 10.判断一个链表是否回文结构
回文：正序和反序一样！
1. 先将链表元素入栈，再从栈弹出元素，其顺序正好就是链表的逆序。在弹出过程中，重新从链表头开始遍历，若每个元素都与弹出元素一样那么就是回文的，否则不是。**但额外空间复杂度不为O(1)，而是O(n)。**
2. <font color=red>快慢指针(常用用于找到链表中间位置)：快指针每次走2步，慢指针走1步。</font>当快指针走到底时，慢指针正好在中间。其实可以将慢指针之后的链表元素入栈，再对比慢指针之前的链表与出栈的元素是否一样，跟1一样，只是栈节省了一般空间，但是O(n);
3. 在2基础上找到中间位置后，将慢指针后面的元素指针方向逆序即变为： 1 → 2 → 3 ← 2 ← 1，其中 3 → null，然后从两头开始往中间遍历，当中间有元素不相同时停止，或者直到其中一个指针为null时停止（偶数情况），比如偶数个时：1 → 2 ← 2 ← 1，其中第一个 2 → null，当左指针为null时就停止。<font color=red>修改链表后需要将链表还原！</font>

##### 11.将单向链表按某值划分为小于区、等于区、大于区
荷兰国旗（partition）的链表形式。
1. 将链表节点放到数组中，按节点值进行partition，然后重新连成链表。空间复杂度O(n)。
2. 第一次遍历一次链表，分别找出小于、等于、大于 pivot 的第一个节点，创建指向他们的指针；再遍历一次链表，将链表中小于、等于、大于 pivot 的节点分别挂在三个新链表的后面（跳过链表头结点）；最后将小于，等于，大于 的3个链表依次相连，则得到 < == > 的三部分；

<font color=red>警告：处理链表时，一定要特别处理最后一个节点的next指针！</font>

##### 12.<11>题的进阶版
要求，原元素partition之后保持在原链表中的相对次序不变。<11>题中的第2种解法满足此要求。

##### 13.复制含有随机指针节点的链表
**解题关键：在原节点与克隆节点建立联系，可以通过原节点方便地找到克隆节点！**
1. 方法1：使用HashMap，将原链表节点作为key，其克隆节点作为value。
2. 方法2：不用HashMap，而去修改链表。将克隆节点插入到原节点后面，这样也可以通过原节点的next指针找到克隆节点。然后分离新旧链表。注意：必须保持原链表结构！

##### 14.两个单链表相交的一系列问题
单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。

**关键：首先要判断链表是否有换，若有环，则返回第一个入环节点。**
1. 遍历链表，将节点放入Set，若重复则有环，且能得到第一个入环节点，时间&空间复杂度O(n)。
2. 快(2步)慢(1步)指针，若快指针走到了null，则无环。若有环，那么Fast和Slow会在环上某个节点相遇，相遇后Fast指向链表开头，变成每次走一步，此时Fast和Slow一起走，则它们会在第一个入环节点相遇。（数学结论）时间复杂度O(n),空间复杂度O(1)。
###### 2个无环链表相交问题
若2条皆是无环单链表（getLoopNode返回都为null），若他们相交只能呈“Y”字型（因为是单链表，一个节点只有一个next指针），否则不相交。
1. 解(1)：使用HashSet。将链表1的所有节点放入HashSet中，然后依次放入链表2的节点，若key已存在则说明相交，返回该节点即可
2. 解(2): 不使用HashSet。分别遍历链表1,2，统计它们的长度len1,len2，以及得到它们的最后一个节点end1,end2，若 end1 ≠ end2 则它们不相交，反之相交。
###### 1个无环另1个有环链表相交问题
因为是单链表，所以这2条链表一定不相交。
###### 2个有环链表相交问题
3种情况:
1. 2条链表在入环之前就已相交：“>-O”这种形状。若抛开“O”部分，那么剩余部分就和前面的<2个无环链表相交问题>一样
2. 2条链表在环上相交：“♉”。找到链表1的入环节点loop1，然后往后走，若在回到loop1之前遇到链表2入环节点loop2，则说明2链表在环上相交，此时返回loop1或loop2都对。若回到loop1时没遇到loop2，则说明它们是独立不相交的有环链表，即第(3)种情况
3. "6 6"型，不相交。

##### 15.反转单&双向链表
太简单略

##### 16.布隆过滤器与一致性哈希
布隆过滤器<br/>
场景：分布式大文件，100亿个64字节的URL，整个文件就是640G，无法放到内存中用哈希表实现。使用布隆过滤器可以解决。
- 布隆过滤器概念上就是集合。
- 常用于爬虫和黑名单任务，用于快速查找某个元素是否存在。
- 实现结构：bit数组，使用`int[]`或`long[]`表示，每一个数组元素有32或64个bit。一个bit指示一个URL是否抹黑。
- 布隆过滤器省空间、一定有失误率(比如误报不在名单的URL，但名单上的URL肯定正确)。失误率：因为后期黑名单太多，数组大部分位置置1了，那么输入的查询内容即使不在名单上，但很可能得到k个位置的bit全为1。
- 布隆过滤器大小与单样本大小无关(因为无论输入多大，都会传给哈希函数输出一个数值)，但和样本数量有关。
- 配置布隆过滤器：只需要输入样本量n和容忍失误率p，即可根据2个公式计算 布隆过滤器的大小m bit和k个(不同)哈希函数。还可根据另一个公式得到真实的失误率(因为m和k为小数都会向上取整，真实失误率<= 容忍失误率p)。

布隆过滤器面试关键4点：
1. 黑名单
2. 单样本占空间大
3. 要求内存空间苛刻
4. 是否允许有失误率(自己问)

一致性哈希<br/>
在分布式系统上经常使用一致性哈希。
- 前台服务器处理前端请求，然后分法到后台服务器存储数据。
- 将hash函数的输出域想象成一个环。将后台存储器的一些信息生成字符串，输入hash函数得到它们在环上的位置。
- 将后台服务器的hash值，存放到有序数组，前台服务器各有一份。当前台服务器处理一个请求时，将请求hash后在该有序数组中二分查找刚好比它大hash值即为要存储的后台服务器的hash值（相当于也把hash值打到环上，在环上顺时针查找直到一个后台存储器的hash值(节点)）。

补充：**插入新机器(节点)转移数据**，比如原来的环是 m1->m2->m3->m1，现插入m4：m1->m2->m4->m3。如何将数据转移：将m2->m4上的数据转移到m4上，即可以对m3上的数据重新hash后，若是在m2->m4范围内就移到m4并从m3删除，否则就留在m3。

以上是非一致性哈希，存在2个问题：
1. 当环上节点(机器)数太少时，hash值不均衡，导致机器负载不均衡
2. 即使打的节点使得机器是均衡的，新加入机器后会破坏原来的均衡。

解决办法：<font color=red>虚拟节点</font>。<br/>
每个机，器假设拥有10000个虚拟节点，3台机器就3 x 10000个虚拟节点。将这些虚拟节点hash后打到环上，因为数量已经达到一定规模了，所以每台机器大致占的1/3，也就是各台机器负载均衡了。若新插入m4时，就给m4 10000个虚拟节点，打在环上，然后将m1~m3的数据根据它们的虚拟节点位置，像上面一样，将数据转移到m4即可。现在就是每台占1/4，也保持了均衡性！




#### 其他补充
贪心算法：提出一种策略，按照这种策略去寻找答案。策略有很多种，各个策略下得到的答案不一定就是正确答案！
为什么某些贪心策略就是能得到正确答案呢？需要证明，现阶段无需去证明，很难！
可以使用对数器来验证你的某个猜想策略的正确性，使用暴力求解得到的正确解与某个贪心策略结果比对，若多样本下全对，那么基本可确定该策略的正确性！

- 笔试时用最快速的解，面试时用空间最小的解吸引面试官。


